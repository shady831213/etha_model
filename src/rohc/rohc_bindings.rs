/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const ROHC_PROFILE_ID_MAJOR_MAX: u32 = 1;
pub const ROHC_PROFILE_ID_MINOR_MAX: u32 = 8;
pub const _FEATURES_H: u32 = 1;
pub const __USE_ANSI: u32 = 1;
pub const _BSD_SOURCE: u32 = 1;
pub const _SVID_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_BSD: u32 = 1;
pub const __USE_SVID: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201103;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 17;
pub const __GLIBC_HAVE_LONG_LONG: u32 = 1;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &[u8; 6usize] = b"stosq\0";
pub const _SIGSET_H_types: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const _STRUCT_TIMEVAL: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_H: u32 = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __have_pthread_attr_t: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const __WCHAR_MIN: i32 = -2147483648;
pub const __WCHAR_MAX: u32 = 2147483647;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WCHAR_MIN: i32 = -2147483648;
pub const WCHAR_MAX: u32 = 2147483647;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ROHC_ETHERTYPE: u32 = 8945;
pub const ROHC_LARGE_CID_MAX: u32 = 16383;
pub const ROHC_SMALL_CID_MAX: u32 = 15;
pub const ROHC_PROFILE_GENERAL: u32 = 65535;
pub const _STRING_H: u32 = 1;
pub const _XLOCALE_H: u32 = 1;
pub const _ASSERT_H: u32 = 1;
#[repr(u32)]
#[doc = " @brief The different ROHC compression/decompression profiles\n\n The ROHC profiles numbers are allocated by the IANA:\n  - see  §8 in the RFC 3095 (ROHCv1)\n  - see  §5 in the RFC 3843 (ROHCv1 IP-only)\n  - see  §7 in the RFC 4019 (ROHCv1 UDP-Lite)\n  - see §11 in the RFC 6846 (ROHCv1 TCP)\n  - see  §8 in the RFC 5252 (ROHCv2)\n\n If you add a new compression/decompression profile, please also add the\n corresponding textual description in \\ref rohc_get_profile_descr.\n\n @ingroup rohc\n\n @see rohc_get_profile_descr"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rohc_profile_t {
    #[doc = " The ROHCv1 Uncompressed profile (RFC 3095, section 5.10)"]
    ROHC_PROFILE_UNCOMPRESSED = 0,
    #[doc = " The ROHCv1 RTP profile (RFC 3095, section 8)"]
    ROHC_PROFILE_RTP = 1,
    #[doc = " The ROHCv1 UDP profile (RFC 3095, section 5.11)"]
    ROHC_PROFILE_UDP = 2,
    #[doc = " The ROHCv1 ESP profile (RFC 3095, section 5.12)"]
    ROHC_PROFILE_ESP = 3,
    #[doc = " The ROHCv1 IP-only profile (RFC 3843, section 5)"]
    ROHC_PROFILE_IP = 4,
    #[doc = " The ROHCv1 IP/UDP/RTP Link-Layer Assisted Profile (LLA) profile\n  (RFC 4362, section 6)"]
    ROHC_PROFILE_RTP_LLA = 5,
    #[doc = " The ROHCv1 TCP profile (RFC 4996)"]
    ROHC_PROFILE_TCP = 6,
    #[doc = " The ROHCv1 UDP-Lite/RTP profile (RFC 4019, section 7)"]
    ROHC_PROFILE_UDPLITE_RTP = 7,
    #[doc = " The ROHCv1 UDP-Lite profile (RFC 4019, section 7)"]
    ROHC_PROFILE_UDPLITE = 8,
    #[doc = " The ROHCv2 RTP/UDP/IP profile"]
    ROHCv2_PROFILE_IP_UDP_RTP = 257,
    #[doc = " The ROHCv2 UDP/IP profile"]
    ROHCv2_PROFILE_IP_UDP = 258,
    #[doc = " The ROHCv2 ESP/IP profile"]
    ROHCv2_PROFILE_IP_ESP = 259,
    #[doc = " The ROHCv2 IP-only profile"]
    ROHCv2_PROFILE_IP = 260,
    #[doc = " The ROHCv2 IP/UDP-Lite/RTP profile"]
    ROHCv2_PROFILE_IP_UDPLITE_RTP = 263,
    #[doc = " The ROHCv2 IP/UDP-Lite profile"]
    ROHCv2_PROFILE_IP_UDPLITE = 264,
    #[doc = " The ROHCv2 IP/UDP-Lite profile"]
    ROHC_PROFILE_MAX = 265,
}
unsafe extern "C" {
    pub fn rohc_get_profile_descr(profile: rohc_profile_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rohc_profile_is_rohcv1(profile: rohc_profile_t) -> bool;
}
unsafe extern "C" {
    pub fn rohc_profile_is_rohcv2(profile: rohc_profile_t) -> bool;
}
unsafe extern "C" {
    pub fn rohc_profile_get_other_version(profile: rohc_profile_t) -> rohc_profile_t;
}
pub type wchar_t = ::std::os::raw::c_int;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub __wait_terminated: wait__bindgen_ty_1,
    pub __wait_stopped: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn __w_termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set___w_termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___w_coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __w_termsig: ::std::os::raw::c_uint,
        __w_coredump: ::std::os::raw::c_uint,
        __w_retcode: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let __w_termsig: u32 = unsafe { ::std::mem::transmute(__w_termsig) };
            __w_termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __w_coredump: u32 = unsafe { ::std::mem::transmute(__w_coredump) };
            __w_coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let __w_retcode: u32 = unsafe { ::std::mem::transmute(__w_retcode) };
            __w_retcode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn __w_stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __w_stopval: ::std::os::raw::c_uint,
        __w_stopsig: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let __w_stopval: u32 = unsafe { ::std::mem::transmute(__w_stopval) };
            __w_stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let __w_stopsig: u32 = unsafe { ::std::mem::transmute(__w_stopsig) };
            __w_stopsig as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    const UNINIT: ::std::mem::MaybeUninit<wait> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wait_terminated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(__wait_terminated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wait_stopped) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(__wait_stopped)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __WAIT_STATUS {
    pub __uptr: *mut wait,
    pub __iptr: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___WAIT_STATUS() {
    const UNINIT: ::std::mem::MaybeUninit<__WAIT_STATUS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__WAIT_STATUS>(),
        8usize,
        concat!("Size of: ", stringify!(__WAIT_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<__WAIT_STATUS>(),
        8usize,
        concat!("Alignment of ", stringify!(__WAIT_STATUS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__uptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__WAIT_STATUS),
            "::",
            stringify!(__uptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__iptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__WAIT_STATUS),
            "::",
            stringify!(__iptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn gnu_dev_makedev(
        __major: ::std::os::raw::c_uint,
        __minor: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t___pthread_mutex_s> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t___pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pthread_mutex_t___pthread_mutex_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__futex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__total_seq) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__total_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wakeup_seq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__wakeup_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__woken_seq) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__woken_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mutex) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nwaiters) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__nwaiters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__broadcast_seq) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__broadcast_seq)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: pthread_rwlock_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __pad1: ::std::os::raw::c_ulong,
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nr_readers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers_wakeup) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__readers_wakeup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writer_wakeup) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__writer_wakeup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nr_readers_queued) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_readers_queued)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nr_writers_queued) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_writers_queued)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__flags)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(u32)]
#[doc = " @brief The status code of several functions in the library API\n\n @ingroup rohc"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rohc_status_t {
    #[doc = " The action was successful"]
    ROHC_STATUS_OK = 0,
    #[doc = " The action was successful but packet needs to be segmented"]
    ROHC_STATUS_SEGMENT = 1,
    #[doc = " The action failed due to a malformed packet"]
    ROHC_STATUS_MALFORMED = 2,
    #[doc = " The action failed because no matching context exists"]
    ROHC_STATUS_NO_CONTEXT = 3,
    #[doc = " The action failed due to a CRC failure"]
    ROHC_STATUS_BAD_CRC = 4,
    #[doc = " The action failed because output buffer is too small"]
    ROHC_STATUS_OUTPUT_TOO_SMALL = 5,
    #[doc = " The action encountered an undefined problem"]
    ROHC_STATUS_ERROR = 6,
}
#[repr(u32)]
#[doc = " @brief ROHC operation modes\n\n The different ROHC operation modes as defined in section 4.4 of RFC 3095.\n\n If you add a new operation mode, please also add the corresponding textual\n description in \\ref rohc_get_mode_descr.\n\n @ingroup rohc\n\n @see rohc_get_mode_descr"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rohc_mode_t {
    #[doc = " Unknown operational mode"]
    ROHC_UNKNOWN_MODE = 0,
    #[doc = " The Unidirectional mode (U-mode)"]
    ROHC_U_MODE = 1,
    #[doc = " The Bidirectional Optimistic mode (O-mode)"]
    ROHC_O_MODE = 2,
    #[doc = " The Bidirectional Reliable mode (R-mode)"]
    ROHC_R_MODE = 3,
}
#[repr(u32)]
#[doc = " @brief The different types of Context IDs (CID)\n\n The different types of Context IDs (CID) a ROHC compressor or a ROHC\n decompressor may use.\n\n Possible values are:\n  \\li \\ref ROHC_LARGE_CID : large CID means that a ROHC compressor or a ROHC\n      decompressor may identify contexts with IDs in the range\n      [0, \\ref ROHC_LARGE_CID_MAX ], ie. it may uniquely identify at\n      most \\e ROHC_LARGE_CID_MAX + 1 streams.\n  \\li \\ref ROHC_SMALL_CID : small CID means that a ROHC compressor or a ROHC\n      decompressor may identify contexts with IDs in the range\n      [0, \\ref ROHC_SMALL_CID_MAX ], ie. it may uniquely identify at\n      most \\e ROHC_SMALL_CID_MAX + 1 streams.\n\n In short, you choose the CID type in function of the number of simultaneous\n streams you have to compress efficiently.\n\n @see ROHC_SMALL_CID_MAX ROHC_LARGE_CID_MAX\n\n @ingroup rohc"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rohc_cid_type_t {
    #[doc = " @brief The context uses large CID\n\n CID values shall be in the range [0, \\ref ROHC_LARGE_CID_MAX]."]
    ROHC_LARGE_CID = 0,
    #[doc = " @brief The context uses small CID\n\n CID value shall be in the range [0, \\ref ROHC_SMALL_CID_MAX]."]
    ROHC_SMALL_CID = 1,
}
#[doc = " A ROHC Context ID (CID)"]
pub type rohc_cid_t = u16;
#[repr(u32)]
#[doc = " @brief The different values of reordering offset\n\n @ingroup rohc_comp"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rohc_reordering_offset_t {
    #[doc = "< No reordering accepted"]
    ROHC_REORDERING_NONE = 0,
    #[doc = "< Reordering accepted on 1/4 of the WLSB"]
    ROHC_REORDERING_QUARTER = 1,
    #[doc = "< Reordering accepted on 1/2 of the WLSB"]
    ROHC_REORDERING_HALF = 2,
    #[doc = "< Reordering accepted on 3/4 of the WLSB"]
    ROHC_REORDERING_THREEQUARTERS = 3,
}
unsafe extern "C" {
    pub fn rohc_version() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rohc_strerror(status: rohc_status_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rohc_get_mode_descr(mode: rohc_mode_t) -> *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[doc = " @brief The different types of ROHC packets\n\n If you add a new packet type, please also add the corresponding textual\n description in \\ref rohc_get_packet_descr."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rohc_packet_t {
    #[doc = "< ROHC IR packet"]
    ROHC_PACKET_IR = 0,
    #[doc = "< ROHC IR-DYN packet"]
    ROHC_PACKET_IR_DYN = 1,
    #[doc = "< ROHC UO-0 packet"]
    ROHC_PACKET_UO_0 = 2,
    #[doc = "< ROHC UO-1 packet (for all non-RTP profiles)"]
    ROHC_PACKET_UO_1 = 3,
    #[doc = "< ROHC UO-1-ID packet (RTP profile only)"]
    ROHC_PACKET_UO_1_ID = 4,
    #[doc = "< ROHC UO-1-TS packet (RTP profile only)"]
    ROHC_PACKET_UO_1_TS = 5,
    #[doc = "< ROHC UO-1-RTP packet (RTP profile only)"]
    ROHC_PACKET_UO_1_RTP = 6,
    #[doc = "< ROHC UOR-2 packet (for all non-RTP profiles)"]
    ROHC_PACKET_UOR_2 = 7,
    #[doc = "< ROHC UO-2 packet (RTP profile only)"]
    ROHC_PACKET_UOR_2_RTP = 8,
    #[doc = "< ROHC UO-2-ID packet (RTP profile only)"]
    ROHC_PACKET_UOR_2_ID = 9,
    #[doc = "< ROHC UO-2-TS packet (RTP profile only)"]
    ROHC_PACKET_UOR_2_TS = 10,
    #[doc = "< ROHC Normal packet (Uncompressed profile only)"]
    ROHC_PACKET_NORMAL = 13,
    #[doc = "< Unknown packet type"]
    ROHC_PACKET_UNKNOWN = 14,
    #[doc = "< TCP co_common packet"]
    ROHC_PACKET_TCP_CO_COMMON = 15,
    #[doc = "< TCP rnd_1 packet"]
    ROHC_PACKET_TCP_RND_1 = 16,
    #[doc = "< TCP rnd_2 packet"]
    ROHC_PACKET_TCP_RND_2 = 17,
    #[doc = "< TCP rnd_3 packet"]
    ROHC_PACKET_TCP_RND_3 = 18,
    #[doc = "< TCP rnd_4 packet"]
    ROHC_PACKET_TCP_RND_4 = 19,
    #[doc = "< TCP rnd_5 packet"]
    ROHC_PACKET_TCP_RND_5 = 20,
    #[doc = "< TCP rnd_6 packet"]
    ROHC_PACKET_TCP_RND_6 = 21,
    #[doc = "< TCP rnd_7 packet"]
    ROHC_PACKET_TCP_RND_7 = 22,
    #[doc = "< TCP rnd_8 packet"]
    ROHC_PACKET_TCP_RND_8 = 23,
    #[doc = "< TCP seq_1 packet"]
    ROHC_PACKET_TCP_SEQ_1 = 24,
    #[doc = "< TCP seq_2 packet"]
    ROHC_PACKET_TCP_SEQ_2 = 25,
    #[doc = "< TCP seq_3 packet"]
    ROHC_PACKET_TCP_SEQ_3 = 26,
    #[doc = "< TCP seq_4 packet"]
    ROHC_PACKET_TCP_SEQ_4 = 27,
    #[doc = "< TCP seq_5 packet"]
    ROHC_PACKET_TCP_SEQ_5 = 28,
    #[doc = "< TCP seq_6 packet"]
    ROHC_PACKET_TCP_SEQ_6 = 29,
    #[doc = "< TCP seq_7 packet"]
    ROHC_PACKET_TCP_SEQ_7 = 30,
    #[doc = "< TCP seq_8 packet"]
    ROHC_PACKET_TCP_SEQ_8 = 31,
    #[doc = "< ROHC IR-CR packet"]
    ROHC_PACKET_IR_CR = 32,
    #[doc = "< ROHCv2 CO-REPAIR packet"]
    ROHC_PACKET_CO_REPAIR = 33,
    #[doc = "< ROHCv2 PT-0-CRC3 packet"]
    ROHC_PACKET_PT_0_CRC3 = 34,
    #[doc = "< ROHCv2 PT-0-CRC7 packet (non-RTP)"]
    ROHC_PACKET_NORTP_PT_0_CRC7 = 35,
    #[doc = "< ROHCv2 PT-1-SEQ-ID packet (non-RTP)"]
    ROHC_PACKET_NORTP_PT_1_SEQ_ID = 36,
    #[doc = "< ROHCv2 PT-2-SEQ-ID packet (non-RTP)"]
    ROHC_PACKET_NORTP_PT_2_SEQ_ID = 37,
    #[doc = "< ROHCv2 PT-0-CRC7 packet (RTP)"]
    ROHC_PACKET_RTP_PT_0_CRC7 = 38,
    #[doc = "< ROHCv2 PT-1-RND packet (RTP)"]
    ROHC_PACKET_RTP_PT_1_RND = 39,
    #[doc = "< ROHCv2 PT-1-SEQ-ID packet (RTP)"]
    ROHC_PACKET_RTP_PT_1_SEQ_ID = 40,
    #[doc = "< ROHCv2 PT-1-SEQ-TS packet (RTP)"]
    ROHC_PACKET_RTP_PT_1_SEQ_TS = 41,
    #[doc = "< ROHCv2 PT-2-RND packet (RTP)"]
    ROHC_PACKET_RTP_PT_2_RND = 42,
    #[doc = "< ROHCv2 PT-2-SEQ-ID packet (RTP)"]
    ROHC_PACKET_RTP_PT_2_SEQ_ID = 43,
    #[doc = "< ROHCv2 PT-2-SEQ-TS packet (RTP)"]
    ROHC_PACKET_RTP_PT_2_SEQ_TS = 44,
    #[doc = "< ROHCv2 PT-2-SEQ-BOTH packet (RTP)"]
    ROHC_PACKET_RTP_PT_2_SEQ_BOTH = 45,
    #[doc = "< ROHC UO-1-ID packet with EXT-0 (RTP profile only)"]
    ROHC_PACKET_UO_1_ID_EXT0 = 46,
    #[doc = "< ROHC UO-1-ID packet with EXT-1 (RTP profile only)"]
    ROHC_PACKET_UO_1_ID_EXT1 = 47,
    #[doc = "< ROHC UO-1-ID packet with EXT-2 (RTP profile only)"]
    ROHC_PACKET_UO_1_ID_EXT2 = 48,
    #[doc = "< ROHC UO-1-ID packet with EXT-3 (RTP profile only)"]
    ROHC_PACKET_UO_1_ID_EXT3 = 49,
    #[doc = "< ROHC UOR-2 packet with EXT-0 (non-RTP profiles)"]
    ROHC_PACKET_UOR_2_EXT0 = 50,
    #[doc = "< ROHC UOR-2 packet with EXT-1 (non-RTP profiles)"]
    ROHC_PACKET_UOR_2_EXT1 = 51,
    #[doc = "< ROHC UOR-2 packet with EXT-2 (non-RTP profiles)"]
    ROHC_PACKET_UOR_2_EXT2 = 52,
    #[doc = "< ROHC UOR-2 packet with EXT-3 (non-RTP profiles)"]
    ROHC_PACKET_UOR_2_EXT3 = 53,
    #[doc = "< ROHC UOR-2 packet with EXT-0 (RTP profile only)"]
    ROHC_PACKET_UOR_2_RTP_EXT0 = 54,
    #[doc = "< ROHC UOR-2 packet with EXT-1 (RTP profile only)"]
    ROHC_PACKET_UOR_2_RTP_EXT1 = 55,
    #[doc = "< ROHC UOR-2 packet with EXT-2 (RTP profile only)"]
    ROHC_PACKET_UOR_2_RTP_EXT2 = 56,
    #[doc = "< ROHC UOR-2 packet with EXT-3 (RTP profile only)"]
    ROHC_PACKET_UOR_2_RTP_EXT3 = 57,
    #[doc = "< ROHC UOR-2-ID packet with EXT-0 (RTP profile only)"]
    ROHC_PACKET_UOR_2_ID_EXT0 = 58,
    #[doc = "< ROHC UOR-2-ID packet with EXT-1 (RTP profile only)"]
    ROHC_PACKET_UOR_2_ID_EXT1 = 59,
    #[doc = "< ROHC UOR-2-ID packet with EXT-2 (RTP profile only)"]
    ROHC_PACKET_UOR_2_ID_EXT2 = 60,
    #[doc = "< ROHC UOR-2-ID packet with EXT-3 (RTP profile only)"]
    ROHC_PACKET_UOR_2_ID_EXT3 = 61,
    #[doc = "< ROHC UOR-2-TS packet with EXT-0 (RTP profile only)"]
    ROHC_PACKET_UOR_2_TS_EXT0 = 62,
    #[doc = "< ROHC UOR-2-TS packet with EXT-1 (RTP profile only)"]
    ROHC_PACKET_UOR_2_TS_EXT1 = 63,
    #[doc = "< ROHC UOR-2-TS packet with EXT-2 (RTP profile only)"]
    ROHC_PACKET_UOR_2_TS_EXT2 = 64,
    #[doc = "< ROHC UOR-2-TS packet with EXT-3 (RTP profile only)"]
    ROHC_PACKET_UOR_2_TS_EXT3 = 65,
    #[doc = "< The number of packet types"]
    ROHC_PACKET_MAX = 66,
}
#[repr(u32)]
#[doc = " @brief The different types of extensions for UO-1-ID and UOR-2* packets\n\n If you add a new extension type, please also add the corresponding textual\n description in \\ref rohc_get_ext_descr."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rohc_ext_t {
    #[doc = "< The EXT-0 extension for UO-1-ID/UOR-2* packets"]
    ROHC_EXT_0 = 0,
    #[doc = "< The EXT-1 extension for UO-1-ID/UOR-2* packets"]
    ROHC_EXT_1 = 1,
    #[doc = "< The EXT-2 extension for UO-1-ID/UOR-2* packets"]
    ROHC_EXT_2 = 2,
    #[doc = "< The EXT-3 extension for UO-1-ID/UOR-2* packets"]
    ROHC_EXT_3 = 3,
    #[doc = "< No extension for UO-1-ID/UOR-2* packets"]
    ROHC_EXT_NONE = 4,
    #[doc = "< Unknown packet extension type"]
    ROHC_EXT_UNKNOWN = 5,
}
unsafe extern "C" {
    pub fn rohc_get_packet_descr(packet_type: rohc_packet_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rohc_get_ext_descr(ext_type: rohc_ext_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rohc_get_packet_type(packet_id: *const ::std::os::raw::c_char) -> rohc_packet_t;
}
unsafe extern "C" {
    pub fn rohc_packet_is_ir(packet_type: rohc_packet_t) -> bool;
}
unsafe extern "C" {
    pub fn rohc_packet_carry_static_info(packet_type: rohc_packet_t) -> bool;
}
unsafe extern "C" {
    pub fn rohc_packet_carry_crc_7_or_8(packet_type: rohc_packet_t) -> bool;
}
#[repr(u32)]
#[doc = " @brief The different levels of the traces\n\n Used for the \\e level parameter of the \\ref rohc_trace_callback2_t\n user-defined callback.\n\n @ingroup rohc\n\n @see rohc_trace_callback2_t\n @see rohc_comp_set_traces_cb2\n @see rohc_decomp_set_traces_cb2"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rohc_trace_level_t {
    #[doc = "< Print debug traces"]
    ROHC_TRACE_DEBUG = 0,
    #[doc = "< Print info (or lower) traces"]
    ROHC_TRACE_INFO = 1,
    #[doc = "< Print warning (or lower) traces"]
    ROHC_TRACE_WARNING = 2,
    #[doc = "< Print error (or lower) traces"]
    ROHC_TRACE_ERROR = 3,
    #[doc = "< The maximum number of trace levels"]
    ROHC_TRACE_LEVEL_MAX = 4,
}
#[repr(u32)]
#[doc = " @brief The different entities concerned by the traces\n\n Used for the source \\e entity parameter of the \\ref rohc_trace_callback2_t\n user-defined callback.\n\n @ingroup rohc\n\n @see rohc_trace_callback2_t\n @see rohc_comp_set_traces_cb2\n @see rohc_decomp_set_traces_cb2"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rohc_trace_entity_t {
    #[doc = "< Compressor traces"]
    ROHC_TRACE_COMP = 0,
    #[doc = "< Decompressor traces"]
    ROHC_TRACE_DECOMP = 1,
    #[doc = "< The maximum number of trace entities"]
    ROHC_TRACE_ENTITY_MAX = 2,
}
#[doc = " @brief The function prototype for the trace callback\n\n User-defined function that is called by the ROHC library every time it\n wants to print something, from errors to debug. User may thus decide what\n traces are interesting (filter on \\e level, source \\e entity, or\n \\e profile) and what to do with them (print on console, storage in file,\n syslog...).\n\n The user-defined function is set by calling:\n  \\li function \\ref rohc_comp_set_traces_cb2 for a ROHC compressor,\n  \\li function \\ref rohc_decomp_set_traces_cb2 for a ROHC decompressor.\n\n Both functions accept the NULL value to fully disable tracing.\n\n @param priv_ctxt  An optional private context, may be NULL\n @param level      The level of the message, @see rohc_trace_level_t\n @param entity     The entity concerned by the traces\n                   @see rohc_trace_entity_t\n @param profile    The number of the profile concerned by the message\n @param format     The format string for the trace message\n\n @ingroup rohc\n\n @see rohc_trace_level_t\n @see rohc_trace_entity_t\n @see rohc_comp_set_traces2_cb\n @see rohc_decomp_set_traces2_cb"]
pub type rohc_trace_callback2_t = ::std::option::Option<
    unsafe extern "C" fn(
        priv_ctxt: *mut ::std::os::raw::c_void,
        level: rohc_trace_level_t,
        entity: rohc_trace_entity_t,
        profile: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    ),
>;
#[doc = " @brief A timestamp for the ROHC library\n\n Could be easily created from \\e struct \\e timespec on UNIX:\n \\code\nstruct rohc_ts rohc_ts;\nstruct timespec unix_ts;\n...\nrohc_ts.sec = unix_ts.tv_sec;\nrohc_ts.nsec = unix_ts.tv_nsec;\n...\n\\endcode\n\n @ingroup rohc"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rohc_ts {
    #[doc = "< The seconds part of the timestamp"]
    pub sec: u64,
    #[doc = "< The nanoseconds part of the timestamp"]
    pub nsec: u64,
}
#[test]
fn bindgen_test_layout_rohc_ts() {
    const UNINIT: ::std::mem::MaybeUninit<rohc_ts> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rohc_ts>(),
        16usize,
        concat!("Size of: ", stringify!(rohc_ts))
    );
    assert_eq!(
        ::std::mem::align_of::<rohc_ts>(),
        8usize,
        concat!("Alignment of ", stringify!(rohc_ts))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_ts),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_ts),
            "::",
            stringify!(nsec)
        )
    );
}
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: __locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: __locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: __locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
unsafe extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
#[doc = " @brief A network buffer for the ROHC library\n\n May represent one uncompressed packet, one ROHC packet, or a ROHC feedback.\n\n The network buffer does not contain the packet data itself. It only has\n a pointer on it. This is designed this way for performance reasons: no copy\n required to initialize a network buffer, the struct is small and may be\n passed as copy to function.\n\n The network buffer is able to keep some free space at its beginning. The\n unused space at the beginning of the buffer may be used to prepend a\n network header at the very end of the packet handling.\n\n The beginning of the network buffer may also be shifted forward with the\n \\ref rohc_buf_pull function or shifted backward with the \\ref rohc_buf_push\n function. This is useful when parsing a network packet (once bytes are\n read, shift them forward) for example.\n\n The network buffer may be initialized manually (see below) or with the\n helper functions \\ref rohc_buf_init_empty or \\ref rohc_buf_init_full.\n \\code\nstruct rohc_buf packet;\n...\npacket.time.sec = 0;\npacket.time.nsec = 0;\npacket.max_len = 100;\npacket.data = malloc(packet.max_len);\npacket.offset = 2;\npacket.len = 2;\npacket[packet.offset] = 0x01;\npacket[packet.offset + 1] = 0x02;\n...\n\\endcode\n\n or as below:\n \\code\nstruct rohc_buf packet;\nunsigned char input[100];\n...\ninput[2] = 0x01;\ninput[3] = 0x02;\n...\npacket.time.sec = 0;\npacket.time.nsec = 0;\npacket.max_len = 100;\npacket.data = input;\npacket.offset = 2;\npacket.len = 2;\n...\n\\endcode\n\n @ingroup rohc"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rohc_buf {
    #[doc = "< The timestamp associated to the data"]
    pub time: rohc_ts,
    #[doc = "< The buffer data"]
    pub data: *mut u8,
    #[doc = "< The maximum length of the buffer"]
    pub max_len: usize,
    #[doc = "< The offset for the beginning of the data"]
    pub offset: usize,
    #[doc = "< The data length (in bytes)"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_rohc_buf() {
    const UNINIT: ::std::mem::MaybeUninit<rohc_buf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rohc_buf>(),
        48usize,
        concat!("Size of: ", stringify!(rohc_buf))
    );
    assert_eq!(
        ::std::mem::align_of::<rohc_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(rohc_buf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_buf),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_buf),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_buf),
            "::",
            stringify!(max_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_buf),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_buf),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rohc_comp {
    _unused: [u8; 0],
}
#[repr(u32)]
#[doc = " @brief The different ROHC compressor states\n\n The different ROHC operation states at compressor as defined in section\n 4.3.1 of RFC 3095. The CR operation state is defined in RFC 4164.\n\n If you add a new compressor state, please also add the corresponding\n textual description in \\ref rohc_comp_get_state_descr.\n\n @ingroup rohc_comp\n\n @see rohc_comp_get_state_descr"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rohc_comp_state_t {
    #[doc = " Unknown compressor state"]
    ROHC_COMP_STATE_UNKNOWN = 0,
    #[doc = " The Initialization and Refresh (IR) compressor state"]
    ROHC_COMP_STATE_IR = 1,
    #[doc = " The First Order (FO) compressor state"]
    ROHC_COMP_STATE_FO = 2,
    #[doc = " The Second Order (SO) compressor state"]
    ROHC_COMP_STATE_SO = 3,
    #[doc = " The Context Replication (CR) compressor state"]
    ROHC_COMP_STATE_CR = 4,
}
#[doc = " @brief Some information about the last compressed packet\n\n The structure is used by the \\ref rohc_comp_get_last_packet_info2 function\n to store some information about the last compressed packet.\n\n Versioning works as follow:\n  - The \\e version_major field defines the compatibility level. If the major\n    number given by user does not match the one expected by the library,\n    an error is returned.\n  - The \\e version_minor field defines the extension level. If the minor\n    number given by user does not match the one expected by the library,\n    only the fields supported in that minor version will be filled by\n    \\ref rohc_comp_get_last_packet_info2.\n\n Notes for developers:\n  - Increase the major version if a field is removed.\n  - Increase the major version if a field is added at the beginning or in\n    the middle of the structure.\n  - Increase the minor version if a field is added at the very end of the\n    structure.\n  - The version_major and version_minor fields must be located at the very\n    beginning of the structure.\n  - The structure must be packed.\n\n Supported versions:\n  - Major 0 / Minor 0 contains: version_major, version_minor, context_id,\n    is_context_init, context_mode, context_state, context_used, profile_id,\n    packet_type, total_last_uncomp_size, header_last_uncomp_size,\n    total_last_comp_size, and header_last_comp_size\n\n @ingroup rohc_comp\n\n @see rohc_comp_get_last_packet_info2"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rohc_comp_last_packet_info2_t {
    #[doc = " The major version of this structure"]
    pub version_major: ::std::os::raw::c_ushort,
    #[doc = " The minor version of this structure"]
    pub version_minor: ::std::os::raw::c_ushort,
    #[doc = " The Context ID (CID)"]
    pub context_id: ::std::os::raw::c_uint,
    #[doc = " Whether the context was initialized (created/re-used) by the packet"]
    pub is_context_init: bool,
    #[doc = " The mode of the last context used by the compressor"]
    pub context_mode: rohc_mode_t,
    #[doc = " The state of the last context used by the compressor"]
    pub context_state: rohc_comp_state_t,
    #[doc = " Whether the last context used by the compressor is still in use"]
    pub context_used: bool,
    #[doc = " The profile ID of the last context used by the compressor"]
    pub profile_id: ::std::os::raw::c_int,
    #[doc = " The type of ROHC packet created for the last compressed packet"]
    pub packet_type: rohc_packet_t,
    #[doc = " The uncompressed size (in bytes) of the last compressed packet"]
    pub total_last_uncomp_size: ::std::os::raw::c_ulong,
    #[doc = " The uncompressed size (in bytes) of the last compressed header"]
    pub header_last_uncomp_size: ::std::os::raw::c_ulong,
    #[doc = " The compressed size (in bytes) of the last compressed packet"]
    pub total_last_comp_size: ::std::os::raw::c_ulong,
    #[doc = " The compressed size (in bytes) of the last compressed header"]
    pub header_last_comp_size: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_rohc_comp_last_packet_info2_t() {
    const UNINIT: ::std::mem::MaybeUninit<rohc_comp_last_packet_info2_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rohc_comp_last_packet_info2_t>(),
        58usize,
        concat!("Size of: ", stringify!(rohc_comp_last_packet_info2_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rohc_comp_last_packet_info2_t>(),
        1usize,
        concat!("Alignment of ", stringify!(rohc_comp_last_packet_info2_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_last_packet_info2_t),
            "::",
            stringify!(version_major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_minor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_last_packet_info2_t),
            "::",
            stringify!(version_minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_last_packet_info2_t),
            "::",
            stringify!(context_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_context_init) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_last_packet_info2_t),
            "::",
            stringify!(is_context_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_mode) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_last_packet_info2_t),
            "::",
            stringify!(context_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_state) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_last_packet_info2_t),
            "::",
            stringify!(context_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_used) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_last_packet_info2_t),
            "::",
            stringify!(context_used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile_id) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_last_packet_info2_t),
            "::",
            stringify!(profile_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packet_type) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_last_packet_info2_t),
            "::",
            stringify!(packet_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_last_uncomp_size) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_last_packet_info2_t),
            "::",
            stringify!(total_last_uncomp_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_last_uncomp_size) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_last_packet_info2_t),
            "::",
            stringify!(header_last_uncomp_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_last_comp_size) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_last_packet_info2_t),
            "::",
            stringify!(total_last_comp_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_last_comp_size) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_last_packet_info2_t),
            "::",
            stringify!(header_last_comp_size)
        )
    );
}
#[doc = " @brief Some general information about the compressor\n\n The structure is used by the \\ref rohc_comp_get_general_info function\n to store some general information about the compressor.\n\n Versioning works as follow:\n  - The \\e version_major field defines the compatibility level. If the major\n    number given by user does not match the one expected by the library,\n    an error is returned.\n  - The \\e version_minor field defines the extension level. If the minor\n    number given by user does not match the one expected by the library,\n    only the fields supported in that minor version will be filled by\n    \\ref rohc_comp_get_general_info.\n\n Notes for developers:\n  - Increase the major version if a field is removed.\n  - Increase the major version if a field is added at the beginning or in\n    the middle of the structure.\n  - Increase the minor version if a field is added at the very end of the\n    structure.\n  - The version_major and version_minor fields must be located at the very\n    beginning of the structure.\n  - The structure must be packed.\n\n Supported versions:\n  - major 0 and minor = 0 contains: version_major, version_minor,\n    contexts_nr, packets_nr, uncomp_bytes_nr, and comp_bytes_nr.\n\n @ingroup rohc_comp\n\n @see rohc_comp_get_general_info"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rohc_comp_general_info_t {
    #[doc = " The major version of this structure"]
    pub version_major: ::std::os::raw::c_ushort,
    #[doc = " The minor version of this structure"]
    pub version_minor: ::std::os::raw::c_ushort,
    #[doc = " The number of contexts used by the compressor"]
    pub contexts_nr: usize,
    #[doc = " The number of packets processed by the compressor"]
    pub packets_nr: ::std::os::raw::c_ulong,
    #[doc = " The number of uncompressed bytes received by the compressor"]
    pub uncomp_bytes_nr: ::std::os::raw::c_ulong,
    #[doc = " The number of compressed bytes produced by the compressor"]
    pub comp_bytes_nr: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_rohc_comp_general_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<rohc_comp_general_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rohc_comp_general_info_t>(),
        36usize,
        concat!("Size of: ", stringify!(rohc_comp_general_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rohc_comp_general_info_t>(),
        1usize,
        concat!("Alignment of ", stringify!(rohc_comp_general_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_general_info_t),
            "::",
            stringify!(version_major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_minor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_general_info_t),
            "::",
            stringify!(version_minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contexts_nr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_general_info_t),
            "::",
            stringify!(contexts_nr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packets_nr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_general_info_t),
            "::",
            stringify!(packets_nr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uncomp_bytes_nr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_general_info_t),
            "::",
            stringify!(uncomp_bytes_nr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comp_bytes_nr) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_comp_general_info_t),
            "::",
            stringify!(comp_bytes_nr)
        )
    );
}
#[repr(u32)]
#[doc = " @brief The different features of the ROHC compressor\n\n Features for the ROHC compressor control whether mechanisms defined as\n optional by RFCs are enabled or not. They can be set or unset with the\n function \\ref rohc_comp_set_features.\n\n @ingroup rohc_comp\n\n @see rohc_comp_set_features"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rohc_comp_features_t {
    #[doc = " No feature at all"]
    ROHC_COMP_FEATURE_NONE = 0,
    #[doc = " Be compatible with 1.6.x versions"]
    ROHC_COMP_FEATURE_COMPAT_1_6_x = 1,
    #[doc = " Do not check IP checksums at compressor"]
    ROHC_COMP_FEATURE_NO_IP_CHECKSUMS = 4,
    #[doc = " Dump content of packets in traces (beware: performance impact)"]
    ROHC_COMP_FEATURE_DUMP_PACKETS = 8,
    #[doc = " Allow periodic refreshes based on inter-packet time"]
    ROHC_COMP_FEATURE_TIME_BASED_REFRESHES = 16,
}
#[doc = " @brief The prototype of the RTP detection callback\n\n User-defined function that is called by the ROHC library for every UDP\n packet to determine whether the UDP packet transports RTP data. If the\n function returns true, the RTP profile is used to compress the packet.\n Otherwise the UDP profile is used.\n\n The user-defined function is set by calling the function\n \\ref rohc_comp_set_rtp_detection_cb\n\n @param ip           The innermost IP packet\n @param udp          The UDP header of the packet\n @param payload      The UDP payload of the packet\n @param payload_size The size of the UDP payload (in bytes)\n @param rtp_private  A pointer to a memory area to be used by the callback\n                     function, may be NULL.\n @return             true if the packet is an RTP packet, false otherwise\n\n @see rohc_comp_set_rtp_detection_cb\n @ingroup rohc_comp"]
pub type rohc_rtp_detection_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        ip: *const ::std::os::raw::c_uchar,
        udp: *const ::std::os::raw::c_uchar,
        payload: *const ::std::os::raw::c_uchar,
        payload_size: ::std::os::raw::c_uint,
        rtp_private: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " @brief The prototype of the callback for random numbers\n\n User-defined function that is called when the ROHC library requires a random\n number. Currently, the ROHC library uses it when initializing the Sequence\n Number (SN) of contexts using the IP-only, IP/UDP, and IP/UDP-Lite profiles.\n\n The user-defined function is set by calling the function\n \\ref rohc_comp_new2\n\n @param comp          The ROHC compressor\n @param user_context  The context given by the user when he/she called the\n                      \\ref rohc_comp_new2 function, may be NULL.\n\n @see rohc_comp_new2\n @ingroup rohc_comp"]
pub type rohc_comp_random_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        comp: *const rohc_comp,
        user_context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn rohc_comp_new2(
        cid_type: rohc_cid_type_t,
        max_cid: rohc_cid_t,
        rand_cb: rohc_comp_random_cb_t,
        rand_priv: *mut ::std::os::raw::c_void,
    ) -> *mut rohc_comp;
}
unsafe extern "C" {
    pub fn rohc_comp_free(comp: *mut rohc_comp);
}
unsafe extern "C" {
    pub fn rohc_comp_set_traces_cb2(
        comp: *mut rohc_comp,
        callback: rohc_trace_callback2_t,
        priv_ctxt: *mut ::std::os::raw::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn rohc_compress4(
        comp: *mut rohc_comp,
        uncomp_packet: rohc_buf,
        rohc_packet: *mut rohc_buf,
    ) -> rohc_status_t;
}
unsafe extern "C" {
    pub fn rohc_comp_pad(
        comp: *mut rohc_comp,
        rohc_packet: *mut rohc_buf,
        min_pkt_len: usize,
    ) -> rohc_status_t;
}
unsafe extern "C" {
    pub fn rohc_comp_get_segment2(comp: *mut rohc_comp, segment: *mut rohc_buf) -> rohc_status_t;
}
unsafe extern "C" {
    pub fn rohc_comp_force_contexts_reinit(comp: *mut rohc_comp) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_profile_enabled(comp: *const rohc_comp, profile: rohc_profile_t) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_enable_profile(comp: *mut rohc_comp, profile: rohc_profile_t) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_disable_profile(comp: *mut rohc_comp, profile: rohc_profile_t) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_enable_profiles(comp: *mut rohc_comp, ...) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_disable_profiles(comp: *mut rohc_comp, ...) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_set_mrru(comp: *mut rohc_comp, mrru: usize) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_get_mrru(comp: *const rohc_comp, mrru: *mut usize) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_get_max_cid(comp: *const rohc_comp, max_cid: *mut usize) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_get_cid_type(comp: *const rohc_comp, cid_type: *mut rohc_cid_type_t) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_set_rtp_detection_cb(
        comp: *mut rohc_comp,
        callback: rohc_rtp_detection_callback_t,
        rtp_private: *mut ::std::os::raw::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_set_features(comp: *mut rohc_comp, features: rohc_comp_features_t) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_deliver_feedback2(comp: *mut rohc_comp, feedback: rohc_buf) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_set_optimistic_approach(comp: *mut rohc_comp, repetitions_nr: usize) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_set_wlsb_window_width(comp: *mut rohc_comp, width: usize) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_set_reorder_ratio(
        comp: *mut rohc_comp,
        reorder_ratio: rohc_reordering_offset_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_set_periodic_refreshes(
        comp: *mut rohc_comp,
        ir_timeout: usize,
        fo_timeout: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_set_periodic_refreshes_time(
        comp: *mut rohc_comp,
        ir_timeout: u64,
        fo_timeout: u64,
    ) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_set_list_trans_nr(comp: *mut rohc_comp, list_trans_nr: usize) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_get_general_info(
        comp: *const rohc_comp,
        info: *mut rohc_comp_general_info_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_get_last_packet_info2(
        comp: *const rohc_comp,
        info: *mut rohc_comp_last_packet_info2_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn rohc_comp_get_state_descr(state: rohc_comp_state_t) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rohc_decomp {
    _unused: [u8; 0],
}
#[repr(u32)]
#[doc = " @brief The ROHC decompressor states\n\n The different ROHC operation states at decompressor as defined in section\n 4.3.2 of RFC 3095.\n\n @ingroup rohc_decomp\n\n @see rohc_decomp_get_state_descr"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rohc_decomp_state_t {
    #[doc = " Unknown decompressor state"]
    ROHC_DECOMP_STATE_UNKNOWN = 0,
    #[doc = " The No Context state"]
    ROHC_DECOMP_STATE_NC = 1,
    #[doc = " The Static Context state"]
    ROHC_DECOMP_STATE_SC = 2,
    #[doc = " The Full Context state"]
    ROHC_DECOMP_STATE_FC = 3,
}
#[doc = " @brief Some information about the last decompressed packet\n\n The structure is used by the \\ref rohc_decomp_get_last_packet_info function\n to store some information about the last decompressed packet.\n\n Versioning works as follow:\n  - The \\e version_major field defines the compatibility level. If the major\n    number given by user does not match the one expected by the library,\n    an error is returned.\n  - The \\e version_minor field defines the extension level. If the minor\n    number given by user does not match the one expected by the library,\n    only the fields supported in that minor version will be filled by\n    \\ref rohc_decomp_get_last_packet_info.\n\n Notes for developers:\n  - Increase the major version if a field is removed.\n  - Increase the major version if a field is added at the beginning or in\n    the middle of the structure.\n  - Increase the minor version if a field is added at the very end of the\n    structure.\n  - The version_major and version_minor fields must be located at the very\n    beginning of the structure.\n  - The structure must be packed.\n\n Supported versions:\n  - Major 0 / Minor 0 contains: version_major, version_minor, context_mode,\n    context_state, profile_id, nr_lost_packets, nr_misordered_packets, and\n    is_duplicated\n  - Major 0 / Minor = 1 added: corrected_crc_failures,\n    corrected_sn_wraparounds, corrected_wrong_sn_updates, and packet_type\n\n @ingroup rohc_decomp\n\n @see rohc_decomp_get_last_packet_info"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rohc_decomp_last_packet_info_t {
    #[doc = " The major version of this structure"]
    pub version_major: ::std::os::raw::c_ushort,
    #[doc = " The minor version of this structure"]
    pub version_minor: ::std::os::raw::c_ushort,
    #[doc = " The mode of the last context used by the compressor"]
    pub context_mode: rohc_mode_t,
    #[doc = " The state of the last context used by the compressor"]
    pub context_state: rohc_decomp_state_t,
    #[doc = " The profile ID of the last context used by the compressor"]
    pub profile_id: ::std::os::raw::c_int,
    #[doc = " The number of (possible) lost packet(s) before last packet"]
    pub nr_lost_packets: ::std::os::raw::c_ulong,
    #[doc = " The number of packet(s) before the last packet if late"]
    pub nr_misordered_packets: ::std::os::raw::c_ulong,
    #[doc = " Is last packet a (possible) duplicated packet?"]
    pub is_duplicated: bool,
    #[doc = " The number of successful corrections upon CRC failure"]
    pub corrected_crc_failures: ::std::os::raw::c_ulong,
    #[doc = " The number of successful corrections of SN wraparound upon CRC failure"]
    pub corrected_sn_wraparounds: ::std::os::raw::c_ulong,
    #[doc = " The number of successful corrections of incorrect SN updates upon CRC\n  failure"]
    pub corrected_wrong_sn_updates: ::std::os::raw::c_ulong,
    #[doc = " The type of the last decompressed ROHC packet"]
    pub packet_type: rohc_packet_t,
    #[doc = " The compressed size (in bytes) of the last decompressed packet"]
    pub total_last_comp_size: ::std::os::raw::c_ulong,
    #[doc = " The compressed size (in bytes) of the last decompressed header"]
    pub header_last_comp_size: ::std::os::raw::c_ulong,
    #[doc = " The uncompressed size (in bytes) of the last decompressed packet"]
    pub total_last_uncomp_size: ::std::os::raw::c_ulong,
    #[doc = " The uncompressed size (in bytes) of the last decompressed header"]
    pub header_last_uncomp_size: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_rohc_decomp_last_packet_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<rohc_decomp_last_packet_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rohc_decomp_last_packet_info_t>(),
        93usize,
        concat!("Size of: ", stringify!(rohc_decomp_last_packet_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rohc_decomp_last_packet_info_t>(),
        1usize,
        concat!("Alignment of ", stringify!(rohc_decomp_last_packet_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_last_packet_info_t),
            "::",
            stringify!(version_major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_minor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_last_packet_info_t),
            "::",
            stringify!(version_minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_last_packet_info_t),
            "::",
            stringify!(context_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_last_packet_info_t),
            "::",
            stringify!(context_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_last_packet_info_t),
            "::",
            stringify!(profile_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nr_lost_packets) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_last_packet_info_t),
            "::",
            stringify!(nr_lost_packets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nr_misordered_packets) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_last_packet_info_t),
            "::",
            stringify!(nr_misordered_packets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_duplicated) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_last_packet_info_t),
            "::",
            stringify!(is_duplicated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).corrected_crc_failures) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_last_packet_info_t),
            "::",
            stringify!(corrected_crc_failures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).corrected_sn_wraparounds) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_last_packet_info_t),
            "::",
            stringify!(corrected_sn_wraparounds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).corrected_wrong_sn_updates) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_last_packet_info_t),
            "::",
            stringify!(corrected_wrong_sn_updates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packet_type) as usize - ptr as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_last_packet_info_t),
            "::",
            stringify!(packet_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_last_comp_size) as usize - ptr as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_last_packet_info_t),
            "::",
            stringify!(total_last_comp_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_last_comp_size) as usize - ptr as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_last_packet_info_t),
            "::",
            stringify!(header_last_comp_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_last_uncomp_size) as usize - ptr as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_last_packet_info_t),
            "::",
            stringify!(total_last_uncomp_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_last_uncomp_size) as usize - ptr as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_last_packet_info_t),
            "::",
            stringify!(header_last_uncomp_size)
        )
    );
}
#[doc = " @brief Some information about one decompression context\n\n The structure is used by the \\ref rohc_decomp_get_context_info function\n to store some information about one decompression context.\n\n Versioning works as follow:\n  - The \\e version_major field defines the compatibility level. If the major\n    number given by user does not match the one expected by the library,\n    an error is returned.\n  - The \\e version_minor field defines the extension level. If the minor\n    number given by user does not match the one expected by the library,\n    only the fields supported in that minor version will be filled by\n    \\ref rohc_decomp_get_context_info.\n\n Notes for developers:\n  - Increase the major version if a field is removed.\n  - Increase the major version if a field is added at the beginning or in\n    the middle of the structure.\n  - Increase the minor version if a field is added at the very end of the\n    structure.\n  - The version_major and version_minor fields must be located at the very\n    beginning of the structure.\n  - The structure must be packed.\n\n Supported versions:\n  - Major 0 / Minor 0 contains: version_major, version_minor, packets_nr,\n    comp_bytes_nr, uncomp_bytes_nr, corrected_crc_failures,\n    corrected_sn_wraparounds, and corrected_wrong_sn_updates.\n\n @ingroup rohc_decomp\n\n @see rohc_decomp_get_context_info"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rohc_decomp_context_info_t {
    #[doc = " The major version of this structure"]
    pub version_major: ::std::os::raw::c_ushort,
    #[doc = " The minor version of this structure"]
    pub version_minor: ::std::os::raw::c_ushort,
    #[doc = " The number of packets processed by the context"]
    pub packets_nr: ::std::os::raw::c_ulong,
    #[doc = " The number of compressed bytes received by the context"]
    pub comp_bytes_nr: ::std::os::raw::c_ulong,
    #[doc = " The number of uncompressed bytes produced by the context"]
    pub uncomp_bytes_nr: ::std::os::raw::c_ulong,
    #[doc = " The number of successful corrections upon CRC failure"]
    pub corrected_crc_failures: ::std::os::raw::c_ulong,
    #[doc = " The number of successful corrections of SN wraparound upon CRC failure"]
    pub corrected_sn_wraparounds: ::std::os::raw::c_ulong,
    #[doc = " The number of successful corrections of incorrect SN updates upon CRC\n  failure"]
    pub corrected_wrong_sn_updates: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_rohc_decomp_context_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<rohc_decomp_context_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rohc_decomp_context_info_t>(),
        52usize,
        concat!("Size of: ", stringify!(rohc_decomp_context_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rohc_decomp_context_info_t>(),
        1usize,
        concat!("Alignment of ", stringify!(rohc_decomp_context_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_context_info_t),
            "::",
            stringify!(version_major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_minor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_context_info_t),
            "::",
            stringify!(version_minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packets_nr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_context_info_t),
            "::",
            stringify!(packets_nr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comp_bytes_nr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_context_info_t),
            "::",
            stringify!(comp_bytes_nr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uncomp_bytes_nr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_context_info_t),
            "::",
            stringify!(uncomp_bytes_nr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).corrected_crc_failures) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_context_info_t),
            "::",
            stringify!(corrected_crc_failures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).corrected_sn_wraparounds) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_context_info_t),
            "::",
            stringify!(corrected_sn_wraparounds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).corrected_wrong_sn_updates) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_context_info_t),
            "::",
            stringify!(corrected_wrong_sn_updates)
        )
    );
}
#[doc = " @brief Some general information about the decompressor\n\n The structure is used by the \\ref rohc_decomp_get_general_info function\n to store some general information about the decompressor.\n\n Versioning works as follow:\n  - The \\e version_major field defines the compatibility level. If the major\n    number given by user does not match the one expected by the library,\n    an error is returned.\n  - The \\e version_minor field defines the extension level. If the minor\n    number given by user does not match the one expected by the library,\n    only the fields supported in that minor version will be filled by\n    \\ref rohc_decomp_get_general_info.\n\n Notes for developers:\n  - Increase the major version if a field is removed.\n  - Increase the major version if a field is added at the beginning or in\n    the middle of the structure.\n  - Increase the minor version if a field is added at the very end of the\n    structure.\n  - The version_major and version_minor fields must be located at the very\n    beginning of the structure.\n  - The structure must be packed.\n\n Supported versions:\n  - major 0 and minor = 0 contains: version_major, version_minor,\n    contexts_nr, packets_nr, comp_bytes_nr, and uncomp_bytes_nr.\n\n @ingroup rohc_decomp\n\n @see rohc_decomp_get_general_info"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rohc_decomp_general_info_t {
    #[doc = " The major version of this structure"]
    pub version_major: ::std::os::raw::c_ushort,
    #[doc = " The minor version of this structure"]
    pub version_minor: ::std::os::raw::c_ushort,
    #[doc = " The number of contexts used by the decompressor"]
    pub contexts_nr: usize,
    #[doc = " The number of packets processed by the decompressor"]
    pub packets_nr: ::std::os::raw::c_ulong,
    #[doc = " The number of compressed bytes received by the decompressor"]
    pub comp_bytes_nr: ::std::os::raw::c_ulong,
    #[doc = " The number of uncompressed bytes produced by the decompressor"]
    pub uncomp_bytes_nr: ::std::os::raw::c_ulong,
    #[doc = " The cumulative number of successful corrections upon CRC failure"]
    pub corrected_crc_failures: ::std::os::raw::c_ulong,
    #[doc = " The cumulative number of successful corrections of SN wraparound\n  upon CRC failure"]
    pub corrected_sn_wraparounds: ::std::os::raw::c_ulong,
    #[doc = " The cumulative number of successful corrections of incorrect SN updates\n  upon CRC failure"]
    pub corrected_wrong_sn_updates: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_rohc_decomp_general_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<rohc_decomp_general_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rohc_decomp_general_info_t>(),
        60usize,
        concat!("Size of: ", stringify!(rohc_decomp_general_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rohc_decomp_general_info_t>(),
        1usize,
        concat!("Alignment of ", stringify!(rohc_decomp_general_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_general_info_t),
            "::",
            stringify!(version_major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_minor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_general_info_t),
            "::",
            stringify!(version_minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contexts_nr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_general_info_t),
            "::",
            stringify!(contexts_nr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packets_nr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_general_info_t),
            "::",
            stringify!(packets_nr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comp_bytes_nr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_general_info_t),
            "::",
            stringify!(comp_bytes_nr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uncomp_bytes_nr) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_general_info_t),
            "::",
            stringify!(uncomp_bytes_nr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).corrected_crc_failures) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_general_info_t),
            "::",
            stringify!(corrected_crc_failures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).corrected_sn_wraparounds) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_general_info_t),
            "::",
            stringify!(corrected_sn_wraparounds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).corrected_wrong_sn_updates) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rohc_decomp_general_info_t),
            "::",
            stringify!(corrected_wrong_sn_updates)
        )
    );
}
#[repr(u32)]
#[doc = " @brief The different features of the ROHC decompressor\n\n Features for the ROHC decompressor control whether mechanisms defined as\n optional by RFCs are enabled or not. They can be set or unset with the\n function \\ref rohc_decomp_set_features.\n\n @ingroup rohc_decomp\n\n @see rohc_decomp_set_features"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rohc_decomp_features_t {
    #[doc = " No feature at all"]
    ROHC_DECOMP_FEATURE_NONE = 0,
    #[doc = " Attempt packet repair in case of CRC failure"]
    ROHC_DECOMP_FEATURE_CRC_REPAIR = 1,
    #[doc = " Be compatible with 1.6.x versions"]
    ROHC_DECOMP_FEATURE_COMPAT_1_6_x = 2,
    #[doc = " Dump content of packets in traces (beware: performance impact)"]
    ROHC_DECOMP_FEATURE_DUMP_PACKETS = 8,
}
unsafe extern "C" {
    pub fn rohc_decomp_new2(
        cid_type: rohc_cid_type_t,
        max_cid: rohc_cid_t,
        mode: rohc_mode_t,
    ) -> *mut rohc_decomp;
}
unsafe extern "C" {
    pub fn rohc_decomp_free(decomp: *mut rohc_decomp);
}
unsafe extern "C" {
    pub fn rohc_decompress3(
        decomp: *mut rohc_decomp,
        rohc_packet: rohc_buf,
        uncomp_packet: *mut rohc_buf,
        rcvd_feedback: *mut rohc_buf,
        feedback_send: *mut rohc_buf,
    ) -> rohc_status_t;
}
unsafe extern "C" {
    pub fn rohc_decomp_get_state_descr(state: rohc_decomp_state_t)
        -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rohc_decomp_get_general_info(
        decomp: *const rohc_decomp,
        info: *mut rohc_decomp_general_info_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_get_context_info(
        decomp: *const rohc_decomp,
        cid: rohc_cid_t,
        info: *mut rohc_decomp_context_info_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_get_last_packet_info(
        decomp: *const rohc_decomp,
        info: *mut rohc_decomp_last_packet_info_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_get_cid_type(
        decomp: *const rohc_decomp,
        cid_type: *mut rohc_cid_type_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_get_max_cid(decomp: *const rohc_decomp, max_cid: *mut usize) -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_set_mrru(decomp: *mut rohc_decomp, mrru: usize) -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_get_mrru(decomp: *const rohc_decomp, mrru: *mut usize) -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_set_prtt(decomp: *mut rohc_decomp, prtt: usize) -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_get_prtt(decomp: *const rohc_decomp, prtt: *mut usize) -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_set_rate_limits(
        decomp: *mut rohc_decomp,
        k: usize,
        n: usize,
        k_1: usize,
        n_1: usize,
        k_2: usize,
        n_2: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_get_rate_limits(
        decomp: *const rohc_decomp,
        k: *mut usize,
        n: *mut usize,
        k_1: *mut usize,
        n_1: *mut usize,
        k_2: *mut usize,
        n_2: *mut usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_set_features(
        decomp: *mut rohc_decomp,
        features: rohc_decomp_features_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_profile_enabled(decomp: *const rohc_decomp, profile: rohc_profile_t)
        -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_enable_profile(decomp: *mut rohc_decomp, profile: rohc_profile_t) -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_disable_profile(decomp: *mut rohc_decomp, profile: rohc_profile_t) -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_enable_profiles(decomp: *mut rohc_decomp, ...) -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_disable_profiles(decomp: *mut rohc_decomp, ...) -> bool;
}
unsafe extern "C" {
    pub fn rohc_decomp_set_traces_cb2(
        decomp: *mut rohc_decomp,
        callback: rohc_trace_callback2_t,
        priv_ctxt: *mut ::std::os::raw::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
